<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Belerofontech - Introducci√≥n a la programaci√≥n con Python - M√≥dulo 4</title>
    <link rel="icon" type="image/png" href="favicon.ico" sizes="any">
    <!-- NOTE: the next line will be (or has been) replaced by the contents of src/slide.css -->
    <style>*{margin:0;padding:0;box-sizing:border-box}#slide{display:none}.slide{white-space:nowrap}.slide-content{align-self:center}@media screen{body{position:absolute;top:50%;left:50%}.slide-3x2{width:1020px;height:680px;margin:-340px 0 0 -510px}.slide-4x3{width:1024px;height:768px;margin:-384px 0 0 -512px}.slide-16x9{width:1024px;height:576px;margin:-288px 0 0 -512px}.slide-16x10{width:1024px;height:640px;margin:-320px 0 0 -512px}.slide{position:absolute;width:100%;height:100%;display:flex;justify-content:center;overflow:hidden}}@media print{body{transform:none!important}img{transform:none!important;min-width:200px;width:100%;display:flex}.slide-root{max-width:100%;display:flex;flex-wrap:wrap;align-items:stretch}.slide-content{transform:none!important}.slide{display:flex;justify-content:center;position:initial;overflow:visible;flex:1;padding:1rem;margin:.5rem .5rem 2rem .5rem;border:1px solid;visibility:visible!important}}</style>
    <!-- NOTE: the next line will load the specific CSS file samefilename.html.css -->
    <script>var scrname = window.location.pathname.split('/').pop(); document.getElementsByTagName("head")[0].insertAdjacentHTML("beforeend", "<link rel=\"stylesheet\" href=\"" + scrname + ".css\"/>");</script>
    <!-- NOTE: the next line will be (or has been) replaced by the contents of customization.css -->
    <style>@media screen,print{body{font-family:'Lato',sans-serif;background-color:#222222;color:#eeeeee;line-height:1.5}.slide a,.slide em{color:#eedd88}.slide img{display:block;margin-left:auto;margin-right:auto}.slide kbd,.slide blockquote{background-color:#eeeeee;border-radius:3px;border:1px solid #aaaaaa;color:#333333;font-weight:700;padding:2px 5px;white-space:nowrap}.slide h2{font-family:'Oswald',sans-serif;font-weight:200;font-size:1.5rem;color:#eedd88}.slide h1{font-family:'Oswald',sans-serif;font-weight:400;font-size:1.8rem;color:#eecc00}.slide h2 a.link-anchor:hover{color:#eedd88}.slide h1 a.link-anchor:hover{color:#eecc00}.slide h2 a.link-anchor,.slide h1 a.link-anchor{color:#222222;text-decoration:none}.slide pre,.slide samp,.slide kbd{font-family:'Inconsolata',monospace;line-height:1.2}.slide.solution pre{color:#222222}.slide samp{color:#eedd88}.slide.noselect{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.slide ul{margin-left:1em}.slide-0{background-color:#eecc00;color:#333333}.slide-0 h1{color:#eeeeee;font-size:2.4rem;text-shadow:1px 1px 3px #666666}.slide-0 h2{color:#333333;text-shadow:1px 1px 3px #666666}.slide-0 a{color:#333333;text-shadow:0px 0px 5px #666666}.slide-0 em,.slide-0 samp{color:#333333}} @media print{body{background-color:#ffffff;color:#000000}}</style>
    <!-- NOTE: the next line will be (or has been) replaced by the contents of src/slide.js -->
    <script>var CLICK_NEXT=0,HISTORY=1,slideNames={},currentSlide=-1,onSearch=!1,INDENT_RE=/^(?:( )+|\t+)/;function trimIndent(e){var t=(e.match(INDENT_RE)||[""])[0].length;if(t>0){var n="^"+e.substring(0,t);return e.replace(new RegExp(n,"mg"),"")}return e}function renderSlide(e,t,n){var i=t.split("\n"),s=-1,r=document.createElement("div"),o=document.createElement("div"),l="";r.className="slide slide-"+n,o.className="slide-content";for(var a=0;a<i.length;a++){var d=i[a];if(d.startsWith("#"))l=d.startsWith("##")?l+"<h2>"+d.substring(2).trim()+"</h2>":l+"<h1>"+d.substring(1).trim()+"</h1>";else if(d.startsWith("`")||d.startsWith("\t")||d.startsWith("  ")){var h;0==(h=d.startsWith("  ")?d.substring(2):d.substring(1)).length&&(h=" "),l=l+"<pre>"+h+"</pre>"}else if(d.startsWith("@NOSELECT@"))r.className+=" noselect";else if(d.startsWith("@NOSCALE@"))r.className+=" noscale",o.className="slide-content-noscale";else if(d.startsWith("@ZOOM@")){var c=d.substring(6).trim();r.className+=" zoom-"+c}else if(d.startsWith("@CLASS@")){var m=d.substring(7).trim();r.className+=" "+m,slideNames[m]=n}else if(d.startsWith("!"))l=l+'<img src="'+d.substring(1).trim()+'" style="max-width: 100%"/>';else if(d.startsWith(":")){var u=d.substring(1).trim(),g='target="_blank"';u.startsWith("#")&&(g=""),l=l+'<a href="'+u+'" '+g+">"+u+"</a>",l+="<br>"}else if(d.startsWith("- "))l=l+"<ul><li>"+d.substring(1).trim()+"</li></ul>";else{if(d.startsWith("\x3c!--"))continue;var y=!0;d.startsWith(".")&&(d=d.substring(1)),"/NOBR/"==(d=d.trim()).substring(d.length-6,d.length)&&(y=!1,d=d.substring(0,d.length-6));for(var w=0;w<d.length;w++){var f=d.charAt(w);"*"==f?-1==s?s=(l+="<strong>").length:(s!=l.length?l+="</strong>":l=l.substring(0,l.length-8)+"*",s=-1):l+=f}0==y||"</blockquote>"==d.substring(d.length-13,d.length)||"</pre>"==d.substring(d.length-6,d.length)?l+="\x3c!-- nobr --\x3e":l+="<br>"}}o.innerHTML=l,r.style.visibility="hidden",r.appendChild(o),e.appendChild(r)}function render(e){var t=document.createElement("div");t.className="slide-root",document.body.appendChild(t);for(var n=(e=trimIndent(e)).split(new RegExp("^\n+","mg")),i=0;i<n.length;i++){renderSlide(t,n[i].trim(),i)}return t}function resize(){var e=window.innerWidth,t=window.innerHeight,n=document.body.offsetWidth,i=document.body.offsetHeight,s=e/t<n/i?e/n:t/i;document.body.style.transform="scale("+s+")",current()}function goTo(e){currentSlide>=0&&(1==HISTORY?window.location.hash=e:window.location.hash.replace(e),currentSlide=e);for(var t=document.querySelectorAll(".slide"),n=0;n<t.length;n++){var i=1,s=t[n],r=s.children[0],o=window.devicePixelRatio/10+.6;(s.className.match("noscale")||onSearch)&&(o=1);var l=s.offsetWidth*o/r.offsetWidth,a=s.offsetHeight*o/r.offsetHeight;if(s.className.match("zoom-")){var d=s.className.match("zoom-.+")[0].split();(i*=(parseInt(d[0].substr(5))||100)/100)<.25?i=.25:i>4&&(i=4)}i*=Math.min(l,a),n==e||onSearch?(r.style.transform="scale("+i+")",currentSlide>=0&&(s.style.visibility="")):onSearch||(s.style.visibility="hidden")}}function next(){goTo(Math.min(currentSlide+1,document.querySelectorAll(".slide").length-1))}function prev(){goTo(Math.max(currentSlide-1,0))}function current(){dest=currentSlide,max=document.querySelectorAll(".slide").length-1,goTo(Math.min(max,Math.max(dest,0)))}function readhash(){return dest=window.location.hash.substring(1)||"0",null!=slideNames[dest]&&(dest=slideNames[dest]),dest}function newhash(){-1!=currentSlide&&(dest=readhash(),max=document.querySelectorAll(".slide").length-1,goTo(Math.min(max,Math.max(dest,0))))}window.onload=function(){render(document.getElementById("slide").innerHTML);var e=readhash();resize(),currentSlide=e,CLICK_NEXT&&(window.onclick=next),window.onresize=resize,window.onwheel=function(e){onSearch||window.event.ctrlKey||window.event.metaKey||window.event.altKey||(e.deltaY>0?next():prev())},window.onkeydown=function(e){if(onSearch||window.event.ctrlKey||window.event.metaKey||window.event.altKey){if(window.event.ctrlKey&&70==e.keyCode||window.event.metaKey&&70==e.keyCode){document.body.style.transform="none";for(var t=document.querySelectorAll(".slide"),n=0;n<t.length;n++){var i=t[n],s=i.children[0];i.style.position="initial",i.style.overflow="hidden",i.style.display="flex",i.style.maxWidth="100%",s.style.padding="1rem",n>0&&(s.style.border="dotted"),i.style.visibility="visible"}onSearch=!0,resize(),window.setTimeout(resize,150)}}else 39==e.keyCode||40==e.keyCode||76==e.keyCode||74==e.keyCode||13==e.keyCode||34==e.keyCode||32==e.keyCode?next():37==e.keyCode||38==e.keyCode||72==e.keyCode||75==e.keyCode||8==e.keyCode||33==e.keyCode?prev():36==e.keyCode?goTo(0):27==e.keyCode&&(window.location.hash=currentSlide)},window.onhashchange=newhash,window.setTimeout(current,150)};</script>
    <!-- NOTE: use CLICK_NEXT=1 to restore the default advance-on-click behaviour... -->
    <!-- NOTE: use HISTORY=0 to avoid pushing browser history elements for each page change! -->
    <style media="screen">@import url(https://fonts.googleapis.com/css?family=Lato:400,700&subset=latin,latin-ext);@import url(https://fonts.googleapis.com/css?family=Oswald:400,700);@import url(https://fonts.googleapis.com/css?family=Inconsolata);</style>
  </head>
  <body class="slide-16x9">
    <pre id="slide">
      # Introducci√≥n a la
      # programaci√≥n con Python
      .
      ## M√≥dulo 4. Estructuras de datos
      .
      `<div style="text-align: right;">¬© 2020 Pachi Sucunza (Belerofontech)</div>
      `<div style="text-align: right;"><a href="https://github.com/pachi-belero" target="_blank">üîó</a> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License">CC BY-NC-SA 4.0</a></div>

      # √çndice
        Colecciones
        Listas
        Igualdad e identidad
        Tuplas
          Inmutabilidad
        Rangos y range()
        Matrices. Pilas y colas
        Operaciones adicionales con cadenas
        f-strings avanzadas
        Escaping
        raw strings. triple-quoted strings
        Diccionarios
        Conjuntos
          sets y multisets
        Juegos de caracteres
        Ejercicios extra
        Referencias
      @ZOOM@ 110

      # Colecciones
      Valores "compuestos" (...)
        "", (), [], {}
      Las cadenas son colecciones tambi√©n!

      # Listas
      Colecci√≥n de elementos con orden/posici√≥n, de
      tama√±o variable/din√°mico, y cualquier profundidad.
      Se asimilan tanto a listas como a vectores/arrays
      de otros lenguajes, aunque son m√°s flexibles.
      .
      Nota: la eficiencia no es tan buena como en arrays,
      por eso se suele usar NumPy (...)
      .
      M√°s detalles sobre listas:
      : https://realpython.com/python-lists-tuples/#python-lists

      Operadores √∫tiles:
        l1 = [1, 2, 3, 4, 5, 6]
        l2 = [7, 8, 9]
        l1 + l2      # concatenaci√≥n de colecciones
        l1 + "hola"  # no es lo intuitivo!
        l = l1 * 2   # repetici√≥n
        e <samp>in</samp> l1      # pertenencia (membership)
        l[i]         # acceso por posici√≥n (subscripting)
        l[-j]        # acceso, posic. contando desde fin
      .
      Nota: no confundir la keyword in aqu√≠ con la de for

      Pueden contener cualquier tipo de objetos:
        l = [1, 'a', 'hola', 7, 5.0]
      .
      Incluidas otras listas (y otras colecciones)
      O sea, se pueden <u>anidar</u>, a cualquier profundidad:
        l = [1, [2, 3]]
        len(l)
        l = [1, 2, [2, 3, [4, 'a'], 5], 7, 8]

      Funciones √∫tiles:
        list.append(e), list.extend(l)  # a√±ade 1 elemento / colecc.
        list.insert(pos, e), list.remove(e), list.pop()  # de 1 en 1
        list.count(e)  # para contar las ocurrencias del elemento
        len(), min(), max(), sum()
        list.index(e)  # Posici√≥n de un elemento
                       # OJO: error si no presente
        list.index(e) if e in list else -1  # ejemplo sin error
      .
      Nota: operan s√≥lo en el primer nivel de profundidad!
        l3 = [1, [2, 3], 4, [5, 6], 7, 8, 9]
        len(l3)
        3 in l3

      <!-- EJERCICIO-PARA-CLASE (DEMO) -->
      # Ejercicio / demo: bucles y funciones con listas
      <blockquote>De una lista de <u>n√∫meros</u>, calcular su suma.<br> /NOBR/
      Se deben aceptar n√∫meros enteros, reales o una mezcla de ambos.<br> /NOBR/
      Mostrar adem√°s el n√∫mero de elementos que hay, los que tienen<br> /NOBR/
      el valor m√≠nimo y el m√°ximo, y los negativos.</blockquote>
      .
        lista = [3, 5, 2.0, -2.5, -1, 99, 8.7654, 0.0]
        print("Suma:", sum(lista))
        print("N√∫mero:", len(lista))
        print("M√≠nimo:", min(lista))
        print("M√°ximo:", max(lista))
        for f in lista:
            if f < 0:
                print("Negativo:", f)
        # avanzado: expresi√≥n equivalente al bucle for anterior
        print("Negativo(s):", [f for f in lista if f < 0])

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 1: rango de n√∫meros<a href="#ejercicio-1" class="link-anchor"> # </a>
      <blockquote>Crear una lista de <u>n√∫meros</u> similar a lo que<br> /NOBR/
      nos devolver√≠a range(). Hacerlo en la forma<br> /NOBR/
      que recibe dos "par√°metros" (inicio, fin).<br> /NOBR/
      Usar s√≥lo bucles y listas (y sus funciones).<br> /NOBR/
      No crear una funci√≥n nuestra ni usar range().</blockquote>
      Opcional: hacer que adem√°s permita "saltos" > 1
      .
      Ejemplo de estructura:
        # Valores para los "par√°metros"
        inicio = 0
        fin = 10
        salto = 1  # opcional
        lista_num = []  # una posibil.: lista vac√≠a
        ...  # aqu√≠ ir√° al menos un bucle
        print("La lista final es:", lista_num)
      @CLASS@ ejercicio-1

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 1-bis: bucles sencillos<a href="#ejercicio-1-bis" class="link-anchor"> # </a>
      <blockquote>Crear una serie de <u>bucles</u> para casos sencillos.</blockquote>
      - Escribir los n√∫meros del 1 al 10
      - Escribir los n√∫meros desde x (entero) a y (entero)<br> siendo x e y variables num√©ricas ya dadas
      - Escribir los n√∫meros impares desde x a y (enteros)<br> siendo x e y variables num√©ricas ya dadas
      - Escribir cada una de las letras de una cadena s (str)<br> en una l√≠nea separada
      .
      Opcional: en lugar de que sean variables con un valor
      ya dado, pedir al usuario los valores para s, x e y
      @CLASS@ ejercicio-1-bis

      <!-- EJERCICIO-PARA-CLASE (DEMO) -->
      # Ejercicio / demo: media con listas
      <blockquote>Pedir una lista de n√∫meros y calcular su media<br> /NOBR/
      aritm√©tica y su suma. Se deben aceptar n√∫meros<br> /NOBR/
      enteros, reales o una mezcla de ambos.<br> /NOBR/
      Pedir una secuencia de valores como una sola<br> /NOBR/
      cadena (una sola l√≠nea) y transformarla en una<br> /NOBR/
      lista, para luego hacer c√°lculos en un bucle y<br> /NOBR/
      finalmente escribir los resultados.</blockquote>
      NOTA: <u>soluci√≥n</u> en la siguiente slide/p√°gina
      Opcional: calcular tambi√©n la mediana (orden!)
      : https://en.wikipedia.org/wiki/Median

      Soluci√≥n (tambi√©n en: <a href="examples/media-y-mediana-con-listas.py" target="_blank">media-y-mediana-con-listas.py</a>):
        cadena = input("Dame la lista de n√∫meros sep. por espacios: ")
        lista = []
        suma = 0.0
        for palabra in cadena.split():
            # Lo que contiene la lista del bucle (cadena.split()) son cadenas!
            # O sea que cada valor necesitamos convertirlo a un n√∫mero (float)
            f = float(palabra)
            lista.append(f)
        # Ahora que ya es una lista de n√∫meros, podemos usar esta operaci√≥n
        suma = sum(lista)
        media = suma / len(lista)
        print(f"La suma es {suma} y la media es {media}.")
      .
      Opcional: calcular tambi√©n la mediana (orden!) (...)

      <!-- EJERCICIO-PARA-CLASE (DEMO) -->
      # Ejercicio / demo: buscar repetidos con listas
      <blockquote>Pedir una lista de palabras como una cadena (separadas por espacios<br> /NOBR/
      solamente), y escribir las palabras que aparezcan repetidas.<br> /NOBR/
      Aceptar (y detectar repetidos) aunque no todo est√© en min√∫sculas.<br> /NOBR/
      No importa si las repeticiones se muestran varias veces...</blockquote>
      No usar str.find() pero s√≠ listas y otras funciones de cadenas (min√∫sculas...)
      Opcional: no mostrar las repeticiones m√°s de una vez
      .
      NOTA: soluci√≥n en: <a href="examples/buscar-repetidos-03-listas.py" target="_blank">buscar-repetidos-03-listas.py</a>

      M√°s funciones...
        del
        list.sort()
        list.reverse()
      .
      Nota: algunas devuelven el "resultado", y otras no!
      Nota: casi todas <u>modifican</u> el contenido de la lista
      con la que operan, salvo unas pocas:
        list.count(), list.index()
      Pero ojo, por ejemplo esto no modifica nada:
        l3 + l2  # por qu√©?

      ## slicing
      Una <u>slice</u> es una porci√≥n ("rodaja") de una colecci√≥n
        l[0:], l[2:3], l[:5], l[0:0]
        l[-3:-1]  # confuso, pero tambi√©n v√°lido (desde el final)
        del l[1:3]
      Uso de slices para copiar/duplicar listas
        l[:]  # DIFERENCIA con str: esto devuelve una NUEVA copia
        l[:] == l, l[:] is l
      Slices con stride ("salto")
        l[::2]
        l[::-1]  # qu√© hace?!
      .
      Ojo: siempre √≠ndices "0-based" e intervalos abierto/cerr.: [ )

      # Igualdad e identidad
      Ejemplo:
        a = [1, 2]
        b = [1, 2]
        a == b
        <samp>True</samp>
        a is b
        <samp>False</samp>
        a[0] is b[0]
        <samp>True</samp>
        id(a)
        <samp>139892470048712</samp>
        id(b)
        <samp>139892470030792</samp>

      Otro ejemplo:
        >>> x = []
        >>> y = x
        >>> y.append(10)
        >>> y
        [10]
        >>> x
        [10]
      Comparar con lo que acabamos de ver... x is y?

      ## copia
      Por lo ya visto, a veces necesitaremos hacer una
      copia diferente (aunque con el mismo contenido
      inicial) de una colecci√≥n (lista o lo que sea)
        l = [1, 2]
        l2 = l.copy()  # o tambi√©n: l2 = l[:]
        l2 = list(l1)  # incluso esto, es lo mismo
        l == l2
        l is l2

      ## Avanzado: copia y clonado
      Pero... en realidad pueden hacerse copias
      "shallow" (superf.) o "deep" (profundas)... No
      hay diferencia cuando no hay anidaci√≥n. Por
      defecto, se hacen superficiales (s√≥lo 1<sup>er</sup> nivel).
      Cuando son "deep" se llama clonar el objeto,
      mientras que si son "shallow" se dice copiar.
      .
      M√°s detalles en la <a href="https://docs.python.org/3/library/copy.html" target="_blank">doc. oficial</a> y tambi√©n
      aqu√≠ (recomendado, m√°s sencillo):
      : https://realpython.com/copying-python-objects/

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 2: repaso con Jupyter<a href="#ejercicio-2" class="link-anchor"> # </a>
      <blockquote>Repaso de listas y bucles, con notebooks de Jupyter de ejemplo, del curso<br> /NOBR/
      "Complete Python Bootcamp", de Jose Portilla (Udemy / GitHub).</blockquote>
      Detalles sobre el curso en:
      : https://www.udemy.com/course/complete-python-bootcamp/
      : https://github.com/Pierian-Data/Complete-Python-3-Bootcamp
      Nota: ir <u>guardando</u> los notebooks en Drive!
      .
      Imprescindibles:
      - Listas: <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/00-Python%20Object%20and%20Data%20Structure%20Basics/04-Lists.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../04-Lists.ipynb</a>
      - Bucles for: <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/02-Python%20Statements/03-for%20Loops.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../03-for Loops.ipynb</a>
      Recomendable (repaso M√≥dulo 3):
      - Bucles while: <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/02-Python%20Statements/04-while%20Loops.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../04-while Loops.ipynb</a>
      Opcional (s√≥lo algunas partes: range, in, etc.):
      - Operadores: <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/02-Python%20Statements/05-Useful-Operators.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../05-Useful-Operators.ipynb</a>
      @CLASS@ ejercicio-2

      # Tuplas
      Secuencias de n elementos (n-tuplas)
        t = (1, 2, 3)
      Se pueden anidar a cualquier profundidad:
        t = (1, (2, 3))
      Se pueden combinar tipos de datos:
        t = (1, 'a', (2, 3), 'hola', [9, 8, 7])
      .
      M√°s sobre tuplas:
      : https://realpython.com/python-lists-tuples/#python-tuples

      Caso especial: tupla de un solo elemento
        (1, )
      Caso especial: tupla vac√≠a
        ()
      .
      Por qu√© hace falta esto? Otros usos de par√©ntesis?
      En realidad con las tuplas lo "definitorio" es la <u>coma</u>
        1,

      ## slicing
      Igual que para las cadenas y listas en casi todo...
        t[0:], t[2:3], t[:5], t[0:0]
      Slices con stride ("salto")
        t[::-1]  # qu√© hace?!
      .
      Nota: el operador de acceso (subscripting) sigue siendo []

      Otras operaciones y funciones muy similares tambi√©n a list:
        len()
        tuple.count()
        tuple.index()  # Posici√≥n de un elemento (error si no est√°)
        in  # pertenencia (devuelve True o False, sin errores)
      etc.

      Importante: las tuplas son <u>inmutables</u>
        t = (1, 'a', (2, 3), 'hola', [9, 8, 7])
        t[0] = 5  # error!
        del t[0]  # error!
      Y los elementos que contienen?
        t[4][0] = 0
        t[4]
        t
      .
      Avanzado: por eso no se pueden (ni hace falta) copiar ni clonar
        t[:]  # IGUAL que en str: esto NO hace NUEVA copia
              # pero tampoco "importa" mucho
        t[:] is t  # en este caso s√≠ devuelve True

      Idea que puede ayudar a entender las tuplas:
      Son un caso particular de listas que <u>no permiten</u>
      <u>realizar modificaciones</u> una vez creadas

      ## Inmutabilidad
      "Immutable objects (numbers, strings and tuples) have a
      fixed value. Such an object cannot be altered. A new object
      will be created if a different value has to be stored"
      .
      Es decir, son mutables los objetos que pueden cambiar de
      valor pero manteniendo su id (ej. listas, dicc., clases).
      Los inmutables son algo as√≠ como constantes (...).
      .
      Todo esto es algo bastante peculiar de Python... lo que
      m√°s importa es <u>recordar qu√© tipos de datos son inmutables</u>
      <u>(cadenas, tuplas, tipos simples)</u> para usarlas en diccionarios
      .
      : https://docs.python.org/3/glossary.html#term-mutable

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 3: tuplas con Jupyter<a href="#ejercicio-3" class="link-anchor"> # </a>
      <blockquote>Repaso de tuplas, con notebooks de Jupyter de ejemplo,<br> /NOBR/
      del curso"Complete Python Bootcamp", de Jose Portilla<br> /NOBR/
      (Udemy / GitHub).</blockquote>
      Nota: ir <u>guardando</u> los notebooks en Drive!
      .
      Tuplas: <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/00-Python%20Object%20and%20Data%20Structure%20Basics/06-Tuples.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../06-Tuples.ipynb</a>
      @CLASS@ ejercicio-3

      # Rangos y range()
      Tipo de dato que "produce" una secuencia de enteros
        range(5)
        for i in range(5):
            print(i)
      .
      Por defecto empiezan en 0
        range(start, stop[, step])
        range(stop)  # start defaults to 0
                     # and step to 1
      Doc.:
        "Return an object that produces a sequence of
        integers from start (inclusive) to stop (exclusive)
        by step."
      <code>range(i, j)</code> produces: <code>i, i+1, i+2, ..., j-1</code>

      Los rangos se "parecen" a una lista, y a veces nos
      podemos confundir, pero realmente no "contienen"
      los elementos sino que los producen uno por uno
      (y si no los vamos consumiendo, no ocupan memoria).
      Veremos cosas similares m√°s adelante (generators...).
        print(range(1, 10))  # qu√© muestra esto?
      .
      En la pr√°ctica, si hace falta los podemos <u>convertir</u>
      f√°cilmente a una lista:
        smallnums = list(range(1, 10))
        print(smallnums)

      Avanzado: unpacking operator (Python >= 3.5):
      Es un operador especial, unario (no es multiplicar!)
        * iterable      # devuelve sus elementos
      Ejemplo:
        >>> list(range(4)) + [4, 5, 6]
        >>> [*range(4), 4, 5, 6]
        [0, 1, 2, 3, 4, 5, 6]
      .
      M√°s detalles (d√≥nde/cu√°ndo se puede usar, etc.)
      : https://www.python.org/dev/peps/pep-0448/

      # Matrices
      Listas de listas
        m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
      .
      En data science se usan mucho m√°s los <u>Pandas Datasets</u>!
      : https://realpython.com/pandas-python-explore-dataset/
      Pandas define las Series (1D) y DataFrames (2D), para
      tratar con datos tabulares (internamente: NumPy)

      # Pilas y colas
      Estructura de datos muy com√∫n. En otros lenguajes,
      suelen tener un tipo propio (o lo debemos crear).
      En Python, normalmente basta con manejar listas
      ## Pilas (stacks): LIFO
        list.append()
        list.pop()  # equivale a list.pop(-1) por defecto
      ## Colas (queues): FIFO
        list.append()
        list.pop(0)

      # Operaciones adicionales con cadenas<a href="#op-cadenas" class="link-anchor"> # </a>
      ## string literal concatenation
      Ejemplos de dos cosas diferentes:
        "hola" + " " + "mundo"    # es una operaci√≥n/expresi√≥n ("suma")
        "hola " '"' "mundo" '"'   # una sola cadena, escrita en trozos
      Lo segundo se usa por comodidad, legibilidad, para facilitar
      el uso de caracteres especiales... Se puede combinar cualquier
      literal de cadena v√°lido (todos los que vamos a ver ahora)
      Es simplemente una <u>notaci√≥n especial</u> para escribir una cadena
      @CLASS@ op-cadenas
      <!-- DESTINO-REFERENCIA-INTERNA-MODULO-4 (DESDE MODULO 2) -->

      ## slicing en cadenas
      Igual que en listas y cualquier otra colecci√≥n!
        "hola"[:2]
        "hola"[::-1]

      <!-- EJERCICIO-PARA-CLASE (OPCIONAL) -->
      # Ejercicio 4 <u>(opcional)</u>: strings con Jupyter<a href="#ejercicio-4" class="link-anchor"> # </a>
      <blockquote>Repaso de tuplas, con notebooks de Jupyter de ejemplo, del curso "Complete<br> /NOBR/
      Python Bootcamp", de Jose Portilla (Udemy / GitHub).</blockquote>
      Nota: ir <u>guardando</u> los notebooks en Drive!
      .
      Strings (b√°sico + slicing): <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/00-Python%20Object%20and%20Data%20Structure%20Basics/02-Strings.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../02-Strings.ipynb</a>
      @CLASS@ ejercicio-4

      ## transformaciones √∫tiles
        str.replace()
        str.strip()  # elimina whitespace al inicio y fin
        str.split()  # separar (por defecto: whitespace)
        str.join()  # une n cadenas (par√°m.) con separador dado
        "".join(tuple('a', 'b', 'c'))  # devuelve 'abc'
        str.lower(), str.upper()
        str.capitalize()  # mayusc. s√≥lo 1er car√°cter
        str.casefold()  # min√∫sc. "agresivas", ej. √ü ‚û° ss
      etc.

      ## otras operaciones y tests
        str.islower()
        str.isupper()
        str.isalpha()
        str.isdecimal()
        str.startswith()
        str.endswith()
      etc.

      ## b√∫squeda (subcadenas)
      Devuelve la posici√≥n de la 1¬™ ocurrencia de sub, o -1
        str.find(sub)
      Lo mismo pero genera error si no hay ocurrencia
        str.index(sub)
      Similar: pertenencia en cadenas
        x in y == True ‚áî x is a substring of y
        x in y == True ‚áî y.find(x) != -1

      ## operador % (de cadenas)
      Nota: en desuso (Python 2)
      Como vimos, es lo m√°s similar al printf() de otros lenguajes
      Ejemplos:
        "size = %0.3f" % ( 5 / 7 )  # flotante; tambi√©n %g %e %E
        "percent = %02d %%" % 5  # entero; tambi√©n %i %u
        "%d = octal %o = hexadecimal %x" % (13, 13, 13)
        "%-4d = car√°cter %c" % (65, 65)  # alineaci√≥n izda.
      Otros formatos interesantes: <pre>%X %s </pre>

      # f-strings avanzadas
      La sintaxis de lo que permite una f-string es:
        ... ::=  "{" f_expression ["="] ["!" conversion] [":" format_spec] "}"
      Es decir, una expresi√≥n entre llaves, y opc. con un "=", conversi√≥n (!) y/o formato (:)
      Ejemplos:
        hola = 59
        f"hola, {hola=}"   # √∫til para debug, etc.
        f"hola, {hola!s}"  # avanzado: conversiones a str especiales (raro uso)
        f"hola, {hola:x}"
        f"{{hola}}, {hola=:x}"  # combinados y con {} "literales"
      .
      Los formatos admitidos son los mismos que en str.format()
      : https://docs.python.org/3/library/string.html#formatspec

      # Escaping
      Notaci√≥n para representar caracteres especiales en cadenas
        \\   Backslash (\)
        \'   Single quote (')
        \"   Double quote (")
        \a   ASCII Bell (BEL)
        \b   ASCII Backspace (BS)
        \f   ASCII Formfeed (FF)
        \n   ASCII Linefeed (LF) - chr(10)
        \r   ASCII Carriage Return (CR) - chr(13)
        \t   ASCII Horizontal Tab (TAB) - chr(9)

      # raw strings
      NO son otro tipo de cadenas! (como tampoco lo son las f-strings)
      Son s√≥lo una <u>notaci√≥n</u> diferente para escribir el c√≥digo fuente
      de forma m√°s "legible" cuando hay muchas barras invert. (\)
        r"a\t\nb"
        len(r"a\t\nb") != len("a\t\nb")
        # el resultado de usar print() en cada una es igual o no?
      .
      Nota: √∫nica excepci√≥n: si hay barra al final del todo, duplicarla
      Por qu√©? Porque siguen "funcionando" las sec. de escape \" y \'

      # triple-quoted strings
        "In triple-quoted literals, unescaped newlines
        and quotes are allowed (and are retained)..."
      Ejemplo:
        """hola
        \t"mundo"
        """
      .
      Es decir: se conserva todo (espacios, \n, \t, e
      incluso las comillas), salvo las tres comillas
      usadas para iniciar y para terminar la cadena
      De nuevo, esto es s√≥lo otra <u>notaci√≥n</u> para str's

      Ejemplo de uso como <u>plantilla</u> (template), con str.format():
        letter = """
        Dear {0} {2}.
          {0}, I have an interesting proposition for you!
          If you deposit ${3} million into my bank account,
          I can double your money ...
        """
        
        print(letter.format("Paris", "W.", "Hilton", 2))
        print(letter.format("Bill", "H.", "Gates", 5))

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 4-bis: producto matricial<a href="#ejercicio-4-bis" class="link-anchor"> # </a>
      <blockquote>Hacer el producto matricial de m ** n, siendo m y n dos matrices de<br> /NOBR/
       dimensiones adecuadas (...).</blockquote>
      Notas:
      - Recordar: este producto no es conmutativo! Se pide m * n, no n * m
      - Usar s√≥lo listas (cualquier funcionalidad), cadenas (?), bucles, if, etc.
      - No usar m√≥dulos matem√°ticos, de matrices, o similares
      - Hacer las comprobaciones necesarias sobre los tama√±os!
      - Opcional: comprobar adem√°s que las matrices son 2D
      - Opcional: comprobar que las matrices contienen s√≥lo flotantes
      - No preocuparse de la "entrada" de los datos de partida ni de la<br> salida. Usar variables ya "dadas" (probar con varias)
      .
      Pistas: pensar en "divide y vencer√°s" (...)
      @CLASS@ ejercicio-4-bis
      <!-- DESTINO-REFERENCIA-INTERNA-MODULO-4 (DESDE MODULO 5) -->

      # Diccionarios
      Similares a una lista, pero indexados con "claves" (keys)
      que pueden ser n√∫meros, cadenas, tuplas... y tampoco tienen
      un orden/posici√≥n en sus elementos
      .
      En otros lenguajes se llaman arrays asociativos o maps:
      asocian un <u>valor</u> a una <u>clave</u> (en lugar de a una posici√≥n)
        edad['Peter'] = 25
      .
      Avanzado: valores permitidos en claves: hashables (ej. inmut.)
      porque internamente requieren poderlas ordenar, por eficiencia.
      Son tambi√©n colecciones pero no secuencias, por el no-orden
      Son "similares" a una lista de 2-tuplas (pero m√°s eficientes!)

      Algunos m√©todos son similares a los de otras colecciones,
      pero no tenemos slicing (no tiene sentido), append(), insert()
      y otros del estilo, ni +. Se a√±aden y eliminan elementos as√≠:
        dic = {}
        dic['z'] = 5  # a√±ade o modifica el valor asociado a 'z'
        dic2 = dic.copy()  # como en listas, porque son mutables
        dic3 = { 'x': 1, 'a': 2 }
        dic.update(dic3)  # a√±ade lo de dic3
        lt = [ ('w', 5), ('r', 2) ]
        dic2.update(lt)  # tambi√©n sirve! y con tuplas de tuplas
        dic4 = dict(lt)  # tambi√©n, para crearlo con ese contenido

      Copia: igual que en otras colecciones <u>mutables</u> (listas)
      Es necesario hacer una copia "expl√≠cita" cuando sea preciso:
        dic2 = dic1.copy()
        dic2 = dict(dic1)  # hace lo mismo
        dic2 = { **dic1 }  # tambi√©n sirve igual (lo veremos)
        dic2 = dic1[:]     # ERROR, no hay slicing!
      .
        dic2 = {}
        dic2.update(dic1)  # incluso as√≠ (2 l√≠neas) tambi√©n

      Los repetidos sobreescriben lo previo
        dic = { 'x': 1, 'a': 2, 'x': 3 }
        len(dic)
      Se puede contener cualquier tipo de datos, y anidar
        d = {'menu': {'id': 'file',
              'value': 'File',
              'popup': {'menuitem': [{'value': 'New', 'onclick': 745635},
                {'value': 'Open', 'onclick': 4535643},
                {'value': 'Close', 'onclick': 3453455}]}}}
        d['menu']['value']
      .
      Veremos las similitudes con JSON m√°s adelante

      Acceso a los elementos: directo o con "vistas"
      Directo:
        dic['z']  # ojo, da error si la clave no existe
        'z' in dic  # devuelve True si la clave existe
        del dic['x']
        dic.pop('z')   # aqu√≠ hay que indicar clave siempre
                       # porque no hay orden: no hay "√∫ltimo"
        dic.popitem()  # parecido a list.pop() pero "al azar"
        dic.get('x')   # si no existe devuelve None, sin error
        dic.get('x', val)  # si no existe devuelve val (√∫til!)

      Vistas (views), son similares a iteradores o a los rangos
        for k in dic.<u>keys</u>():  # "vista" de las claves del diccionario
          print("Hay una clave ", k)
        dic.keys()
        list(dic.keys())
        for k in dic:  # por comodidad, igual que con keys()
          print("Hay una clave ", k)
        for v in dic.<u>values</u>():  # itera en los valores, no claves
          print("Hay un valor ", v)
      Si necesitamos ambas cosas a la vez:
        for k, v in dic.<u>items</u>():
            print("Hay una clave ", k, " con valor ", v)

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 5: diccionarios con Jupyter<a href="#ejercicio-5" class="link-anchor"> # </a>
      <blockquote>Repaso de diccionarios, con notebooks de Jupyter de ejemplo, del curso<br> /NOBR/
      "Complete Python Bootcamp", de Jose Portilla (Udemy / GitHub).</blockquote>
      Nota: ir <u>guardando</u> los notebooks en Drive!
      .
      Diccionarios: <a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/00-Python%20Object%20and%20Data%20Structure%20Basics/05-Dictionaries.ipynb" target="_blank">.../Complete-Python-3-Bootcamp/.../05-Dictionaries.ipynb</a>
      @CLASS@ ejercicio-5

      <!-- EJERCICIO-PARA-CLASE (DEMO) -->
      # Ejercicio / demo: recorrer diccionarios
      <blockquote>Dado un diccionario con valores de tipo num√©rico,<br> /NOBR/
      recorrerlo y crear otro que s√≥lo contenga los elementos<br> /NOBR/
      del primero (pares clave - valor) con valores enteros.</blockquote>
      Nota: preguntar c√≥mo saber si son enteros, en caso de
      duda (se puedehacer de varias formas...). Pistas:
        type()
        int()
        round()
        ...
      .
      Soluci√≥n casi completa en: <a href="examples/recorrer-diccionarios.py" target="_blank">recorrer-diccionarios.py</a>

      <!-- EJERCICIO-PARA-CLASE -->
      # Ejercicio 6: modificar diccionarios<a href="#ejercicio-6" class="link-anchor"> # </a>
      <blockquote>A partir de la soluci√≥n del <u>ejercicio anterior</u>, modificarla<br> /NOBR/
      para que cada "registro" de un tipo de fruta incluya adem√°s<br> /NOBR/
      del tipo de fruta y su cantidad, el nombre del <u>proveedor</u>.<br> /NOBR/
      A√±adir ese dato con 2 o 3 proveedores ficticios, en los<br> /NOBR/
      datos de ejemplo del inicio del programa (dicc1 y dicc2).<br> /NOBR/
      Hacer que ahora el programa escriba tambi√©n una suma<br> /NOBR/
      agregada de cantidades (suponer que ahora representan <u>kg</u>),<br> /NOBR/
      agrupada por proveedor (o sea, el peso total por proveedor).</blockquote>
      Opcional: a√±adir otro "campo" para cada fruta con un <u>emoticono</u>,
      y escribirlo con el nombre de √©sta cada en los listados (Unicode!)
      .
      Soluci√≥n al anterior en: <a href="examples/recorrer-diccionarios.py" target="_blank">recorrer-diccionarios.py</a>
      @CLASS@ ejercicio-6

      <!-- EJERCICIO-PARA-CLASE (DEMO) -->
      # Ejercicio / demo: contar frecuencias
      <blockquote>Dada una lista de palabras (cadena), usando diccionarios almacenar<br> /NOBR/
      la frecuencia de aparici√≥n de cada palabra (separador: espacios)<br> /NOBR/
      y despu√©s mostrar s√≥lo las que aparecen m√°s de dos veces.</blockquote>
      Nota: no usar ninguna funci√≥n de cadenas no vista hasta ahora
      .
      Pistas (opcionales, se puede hacer de otras formas):
        dic.get(..., 0)  # si no existe devuelve 0
        for pal, frec in dic.items():
            ...
      .
      Soluci√≥n en: <a href="examples/contar-frecuencias-diccionarios.py" target="_blank">contar-frecuencias-diccionarios.py</a>

      Avanzado: unpacking operator (Python >= 3.5):
      Es un operador especial, unario (no es exponente!)
        ** diccionario    # devuelve sus elementos (k, v)
      Ejemplo:
        >>> fruit_prices = {'apple': 0.40, 'orange': 0.35}
        >>> vegetable_prices = {'pepper': 0.20, 'onion': 0.55}
        >>> all_prices = {**vegetable_prices, **fruit_prices}
        >>> for k in all_prices:
        ...     print(f"{k} => {all_prices[k]}")
      .
      M√°s detalles (d√≥nde/cu√°ndo se puede usar, etc.)
      : https://www.python.org/dev/peps/pep-0448/

      M√°s detalles sobre diccionarios:
      : https://realpython.com/python-dicts/
      .
      <em>Quizz</em> (auto-examen tipo test) sobre diccionarios:
      : https://realpython.com/quizzes/python-dicts/

      # Conjuntos
      ## sets
      Son colecciones no ordenadas de elementos distintos
      Es decir, no son secuencias: no slicing, indexing...
      .
      Avanzado: valores permitidos: hashables (ej. inmut.)
      Son mutables (existen los frozenset que no lo son...)

      Sintaxis y muchas operaciones similares a los dict,
      pero s√≥lo con la parte de las claves (no hay valores)
        s = set()  # vac√≠o, √∫nica notaci√≥n posible para esto
        s = set({'a', 'b', 'c', 1, 2, 'z'})  # o listas, etc.
        len()
        in
        set.copy(), set.update(), set.pop()...
      .
      √ötil verlos (y usarlos) como dicc. especializados para
      saber s√≥lo si una clave existe o no (da igual el valor)

      Operaciones especializadas y otras "especiales"
        s <= s2  # True si s es un subconjunto de s2
        s.issubset(s2)  # lo mismo
        s < s2  # True si s es un subconj. "estricto"
        s.union(...)
        s | s2  # equivalente a union
        s.isdisjoint(s2)  # True si son disjuntos
        s.intersection(s2)  # equivale a: s & s2
      etc.
      .
      Avanzado: debido a que &lt; tiene este uso "especial",
      no est√° definido el orden entre 2 sets

      <!-- EJERCICIO-PARA-CLASE (DEMO) -->
      # Ejercicio / demo: eliminar repetidos con sets
      <blockquote>Dada una lista de palabras como una cadena (separadas por espacios<br> /NOBR/
      solamente), eliminar las palabras que aparezcan repetidas. Asumir<br> /NOBR/
      que todo est√° siempre en min√∫sculas.<br> /NOBR/
      No importa si el resultado se da en desorden....</blockquote>
      Opcional: mejorar lo de las min√∫sculas (se complica bastante)
      .
        c = "hola que tal mi nombre es tal y tal"
        c += " y dicen que digo mucho tal"
        l = c.split()
        s = set(l)  # set, que eliminar√° los repetidos por definici√≥n!
        print(len(l), len(s), s)

      ## multisets
      Conjuntos que permiten varias instancias de cada elemento
      En algunos lenguajes se llaman msets o bags
      : https://en.wikipedia.org/wiki/Multiset
      .
      En Python, se suele usar <u>Counter</u> del m√≥dulo collections,
      que son unos diccionarios especializados con a√±adidos √∫tiles
      : https://docs.python.org/3/library/collections.html#collections.Counter

      ## Otras estructuras de datos
      Dependiendo del √°mbito de trabajo, es habitual usar tambi√©n:
      - Colas con prioridad
      - Listas enlazadas
      - √Årboles
      - etc.

      # Juegos de caracteres<a href="#juegos-caracteres" class="link-anchor"> # </a>
      ## Unicode
      Est√°ndar (y organismo) para la codificaci√≥n, representaci√≥n
      y manejo de texto. Define un <u>repertorio/"juego"</u> de todos los
      posibles caracteres (y algunos s√≠mbolos especiales, ej. üéµ üòâ)
      para todos los idiomas (alfabetos) y sistemas de escritura.
      Actualmente define unos 114K caracteres, ampliables a 1.1M, y
      a cada uno se le asigna un "code point" (n√∫mero). Ej: U+1F609
      .
      Existen otros juegos de caracteres m√°s antiguos (...)
      @CLASS@ juegos-caracteres
      <!-- DESTINO-REFERENCIA-INTERNA-MODULO-4 (DESDE MODULO 2) -->

      ## Codificaci√≥n de caracteres (character encoding)
      Es el mecanismo para procesar, almacenar y transmitir texto
      (como una secuencia de bytes/n√∫meros).
      Son un convenio (reglas/tablas) para asignar code points a
      caracteres de manera inequ√≠voca
      Ejemplos: Morse, ASCII, UTF-8 y UTF-16 (√©stos, de Unicode)

      ## UTF-8
      Es la codif. de caracteres m√°s habitual en Web y Linux
      Es el <u>recomendado</u> siempre
      .
      En Python 3, todo es Unicode con UTF-8, y nos "despreocupamos"
      excepto cuando <u>leemos o escribimos ficheros</u> (hay que definir c√≥mo)
      o cuando tenemos que interactuar con algo que exija otra codif.
      Hay funciones para convertir texto entre distintos encodings.
      <!-- REFERENCIA-INTERNA-A-MODULO-10 -->
      Veremos m√°s detalles en el <a href="M√≥dulo 10. Entrada-Salida y manipulaci√≥n de datos avanzada.html#juegos-caracteres" target="_blank">M√≥dulo 10</a>

      # Escaping (cont.)
      Se permiten secuencias de escape especiales (Unicode) en Python
        \N{name}     Character named name in the Unicode database
        \uxxxx       Character with 16-bit hex value xxxx
        \Uxxxxxxxx   Character with 32-bit hex value xxxxxxxx

      Ejemplos
        unic = '\N{WINKING FACE}'
        unic2 = 'üòâ'
        print(unic)
        print(unic == unic2)
        print(unic == '\U0001F609')
        print(ord('Âπ¥'))
        Âπ¥ = 2018
        print(Âπ¥)
        ÿπÿßŸÖ = 2019  # ojo lenguajes RTL!
        print(ÿπÿßŸÖ)
      Funciones que trabajan con los "code point":
        len(), chr(), ord()

      Sobre el soporte de Unicode y UTF-8:
      Para que un programa o Web "funcione bien" en cuanto a la
      codificaci√≥n de caracteres (mostrar todos correctamente,
      etc.) se requiere que est√© preparado, y el S.O. tambi√©n.
      La consola Windows por ejemplo no suele estarlo.
      Alternativa recom.: nueva Windows Terminal (opensource)
      Desde la Windows Store si se puede (recom.):
      : https://aka.ms/terminal
      O manual (no se actualiza sola) - msixbundle en "Assets":
      : https://github.com/microsoft/terminal/releases

      # Ejercicios extra
      <ul><li>Recomendados: notebooks de Jupyter de tipo auto-evaluaci√≥n, del curso<br> "Complete Python Bootcamp", de Jose Portilla (Udemy / GitHub):
      <ul><li><a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/00-Python%20Object%20and%20Data%20Structure%20Basics/09-Objects%20and%20Data%20Structures%20Assessment%20Test.ipynb/" target="_blank">Evaluaci√≥n: Objetos y m√°s (tipos b√°sicos, listas, tuplas, diccionarios, etc.)</a></li></ul> /NOBR/
      <ul><li><a href="https://github.com/Belerofontech/Complete-Python-3-Bootcamp/blob/master/02-Python%20Statements/07-Statements%20Assessment%20Test.ipynb" target="_blank">Evaluaci√≥n: bucles y range (comprehensions por ahora no, muy avanzado)</a></li></ul> /NOBR/
      <ul><li>etc. (hay m√°s...)</li></ul></li></ul> /NOBR/
      - Avanzado: ordenar una lista de elementos (del mismo tipo), con varios bucles
      - The Python Challenge (continuar/repetir el 3, que est√° resuelto):<br> <a href="http://www.pythonchallenge.com/" target="_blank">www.pythonchallenge.com</a>
      - En el libro "Automate the Boring Stuff with Python (2¬™ ed.)", gratuito online<br> (<a href="https://automatetheboringstuff.com/" target="_blank">automatetheboringstuff.com</a>), ver los "Practice Projects" en cada cap√≠tulo
      - NOTA: en Youtube, los primeros temas del libro (es como una "demo"<br> explicada de los conceptos, no son realmente ejercicios tal cual):<br> <a href="https://www.youtube.com/watch?v=1F_OgqRuSdI&list=PL0-84-yl1fUnRuXGFe_F7qSH1LEnn9LkW" target="_blank">youtube.com/watch?v=1F_OgqRuSdI&list=...</a>

      # Referencias
      Como otras veces, un buen resumen de lo principal y algunos ejercicios al final:
      : https://openbookproject.net/thinkcs/python/english3e/lists.html
      : https://openbookproject.net/thinkcs/python/english3e/tuples.html
      : https://openbookproject.net/thinkcs/python/english3e/dictionaries.html
      : https://openbookproject.net/thinkcs/python/english3e/strings.html
      Muy recomendable y sencillo, bien explicado, sobre f-strings:
      : https://realpython.com/python-f-strings/
      Curso "Complete Python Bootcamp", de Jose Portilla:
      : https://www.udemy.com/course/complete-python-bootcamp/

    </pre>
  </body>
</html>
